## Проецирование и рендер

#### Общий алгоритм проекции

Пройдёмся по алгоритму отображения 3D модели на 2D экран. Оно состоит из нескольких этапов:

1. **Преобразование вершин** через матрицу проекции.
2. **Масштабирование** координат под разрешение экрана.
3. **Смещение** для корректного позиционирования.

#### Камера

Для начала, нам нужно понять, как объект будет отображаться. Мы используем перспективную проекцию, из-за этого просто так объект отобразить корректно не получится. Далее, когда мы будем удалять не нужные треугольники, возникнет визуальный дефект, так как программа не знает, относитьльно чего мы рендерим объекты. По этому, что бы избежать правок после, мы создадим простую камеру, которая будет иметь лишь заданную позицию.

---

### Реализация

#### Структура `Camera`

```cpp
class Camera {
public:
    // Конструктор по умолчанию
    Camera() = default;
    // Конструктор с заданием направления и позиции
    Camera(Vec3d position) : pos(position) {}

    // Возвращает текущую позицию камеры
    Vec3d getPos() { return pos; }

private:
    // Позиция камеры
    Vec3d pos = Vec3d(0);
};
```

#### Структура `Render`

```cpp
class Render {
public:
    // Конструктор (принимает камеру)
    Render(Camera& camera);

    // Добавление модели в список для рендеринга
    void addMesh(Mesh& mesh) {
        m_renderMeshes.emplace_back(&mesh);
    }
    // Обновление матрицы проекции
    void update();
    // Отрисовка сцены
    void render(sf::RenderWindow& window) {
        // Треугольники после проекции
        std::vector<Triangle> projectedTriangles;

        // Буферы для отрисовки треугольников и рёбер
        sf::VertexArray drawingEdges(sf::PrimitiveType::Lines);
        // Цвет рёбер
        sf::Color edgeColor(255, 128, 0);

        // Обработка всех моделей
        for (auto& mesh : m_renderMeshes) {
            // Получение треугольников
            std::vector<Triangle> triangles = mesh->getTriangles();

            // Обработка каждого треугольника
            for (auto& triangle : triangles) {
                // Проверка видимости задней грани (если включено)
                if (triangle.getNormal().dot(triangle.p[0] - m_camera.getPos()) < 0) {
                    // Применение матрицы вида
                    Triangle projectedTriangle = triangle;

                    // Применение матрицы проекции
                    projectedTriangle *= matProj;

                    // Проецирование и масштабирование треугольника
                    projectedTriangle.projectionDiv();
                    projectedTriangle.scalingToDisplay();

                    // Добавление треугольника в список
                    projectedTriangles.emplace_back(projectedTriangle);
                }
            }
        }

        // Отрисовка объекта
        for (const auto& triangle : projectedTriangle) {
            // Отрисовка рёбер (если включено)
            if (glbl::render::edgeVisible) {
                drawingEdges.append(sf::Vertex{sf::Vector2f(triangle.p[0].x, triangle.p[0].y), edgeColor});
                drawingEdges.append(sf::Vertex{sf::Vector2f(triangle.p[1].x, triangle.p[1].y), edgeColor});
                drawingEdges.append(sf::Vertex{sf::Vector2f(triangle.p[1].x, triangle.p[1].y), edgeColor});
                drawingEdges.append(sf::Vertex{sf::Vector2f(triangle.p[2].x, triangle.p[2].y), edgeColor});
                drawingEdges.append(sf::Vertex{sf::Vector2f(triangle.p[2].x, triangle.p[2].y), edgeColor});
                drawingEdges.append(sf::Vertex{sf::Vector2f(triangle.p[0].x, triangle.p[0].y), edgeColor});
            }
        }

        window.draw(drawingEdges);
    }

private:
    // Список моделей для рендеринга
    std::vector<Mesh*> m_renderMeshes;

    // Камера (для вычисления матриц вида и проекции)
    Camera& m_camera;

    // Матриц проекции
    Mat4x4 matProj;
};
```

#### Импорт в основной класс

В основном классе `Engine` нашего движка нужно создать объекты реализованных классов. С камерой всё просто, мы создаём её с нужной позицией и передаём в конструктор `Render` при его создании. После создания объекта рендера, нам нужно использовать его метод `update` в методе `update` класса `Engine`, а метод `render` в методе `draw`, передав в него наше окно *SFML*.
