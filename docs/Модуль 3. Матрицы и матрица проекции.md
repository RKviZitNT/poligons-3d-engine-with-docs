## Матрицы и матрица проекции

Матрицы играют ключевую роль в 3D-графике, так как они позволяют выполнять преобразования объектов в пространстве, такие как перемещение, вращение, масштабирование и проекцию. Матрица проекции — это особый тип матрицы, который используется для преобразования 3D-координат в 2D-координаты экрана, учитывая перспективу и соотношение сторон.

---

### Матрицы в 3D-графике
Матрица — это математическая структура, состоящая из строк и столбцов, которая используется для выполнения линейных преобразований. В 3D-графике чаще всего используются матрицы 4x4, так как они позволяют выполнять аффинные преобразования (перемещение, вращение, масштабирование) и проекцию.

#### Основные преобразования:
1. **Проекция (Projection)** — преобразование 3D-координат в 2D-координаты экрана.
2. **Масштабирование (Scaling)** — изменение размера объекта.
3. **Перемещение (Translation)** — изменение положения объекта в пространстве.
4. **Вращение (Rotation)** — поворот объекта вокруг осей X, Y или Z.

---

### Матрица проекции
Матрица проекции используется для преобразования 3D-координат в 2D-координаты экрана. Она учитывает перспективу, область видимости (frustum) и соотношение сторон экрана. Матрица проекции преобразует координаты из пространства камеры в нормализованные координаты экрана. В 3д графике координаты на экране задаются от -1 до 1.

![Экран](images/Screen.png)

#### Основные параметры матрицы проекции:
1. **Область видимости (Frustum)**:
   - Задаётся ближней (near) и дальней (far) плоскостями отсечения, а также углом обзора (field of view).

2. **Зависимость от оси Z**:
   - Чем дальше объект от камеры, тем меньше он кажется. Это достигается за счёт деления координат на компоненту W (перспективное деление). Но, прежде чем делить на W нужно расчитать, насколько объект далеко от камеры, расчитывать мы будем по следующим формулам: \( Z\frac{ZFar}{ZFar-ZNear} \); \( -\frac{ZFar \cdot ZNear}{ZFar-ZNear} \)

![Проекция](images/Projection1.png)

3. **Масштабирование (нормализация)**:
   - Учитывает соотношение сторон экрана (aspect ratio), чтобы объекты не искажались при отрисовке, так как координаты экрана у нас задаются теперь от -1 до 1, то нужно одну из сторон домножать на частное сторон исходного экрана. Но также не стоит забывать, что по отдалению объекта, он не только начинает уменьшаться, но и становится ближе к центру или к краю экрана, а значит нам проецировать его на экран исходя из того, как далеко он находится. Посмотрев на рисунок, мы можем увидеть прямой угол, а значит тут можно применить тангенс и, т.к. у нас получается 2 угла, то мы должны поделить наш угол обзора (FOV) на 2. В итоге мы получим формулу \( \frac{1}{\tan(\frac{\theta}{2})} \)

![Проекция](images/Projection2.png)

#### Расчитанная матрица проекции:
\[
\begin{bmatrix}
\left(\frac{n}{w}\right) \cdot \frac{1}{\tan(\theta / 2)} & 0 & 0 & 0 \\
0 & \frac{1}{\tan(\theta / 2)} & 0 & 0 \\
0 & 0 & \frac{Z_{far}}{Z_{far} - Z_{near}} & 1 \\
0 & 0 & \frac{-Z_{far} \cdot Z_{near}}{Z_{far} - Z_{near}} & 0
\end{bmatrix}
\]

---

### Реализация

#### Структура `Mat4x4`
```cpp
class Mat4x4 {
public:
    // Матрица 4x4 (двумерный массив)
    std::array<std::array<float, 4>, 4> m;

    // Конструктор по умолчанию
    Mat4x4() = default;
    // Инициализация списком значений
    Mat4x4(std::initializer_list<std::initializer_list<float>> values) {
        Mat4x4 result;
        for (size_t i = 0; i < 4; ++i) {
            for (size_t j = 0; j < 4; ++j) {
                result.m[i][j] = 0;
                for (size_t k = 0; k < 4; ++k) {
                    result.m[i][j] += this->m[i][k] * mat.m[k][j];
                }
            }
        }
        return result;
    }

    // Матрица проекции
    static Mat4x4 projection(float fNear, float fFar, float fFov, float fAspectRatio) {
        // Преобразование угла обзора в радианы
        float fFovRad = 1.f / tanf(fFov * 0.5f * glbl::rad);
        return Mat4x4{
            { fAspectRatio * fFovRad,  0,        0,                                 0 },
            { 0,                       fFovRad,  0,                                 0 },
            { 0,                       0,        fFar / (fFar - fNear),             1 },
            { 0,                       0,        (-fFar * fNear) / (fFar - fNear),  0 }
        };
    }
};
```

#### Добавим в `Vec3d` и `Triangle` возможность умножения на матрицу

```cpp
// Vec3d
// Добавляем в класс перегрузку опрератора (актуально для c++), в других языках можно реализовать обычным методом

// Умножение вектора на матрицу 4x4
Vec3d operator*(const Mat4x4& mat) {
    Vec3d result;
    result.x = x * mat.m[0][0] + y * mat.m[1][0] + z * mat.m[2][0] + w * mat.m[3][0];
    result.y = x * mat.m[0][1] + y * mat.m[1][1] + z * mat.m[2][1] + w * mat.m[3][1];
    result.z = x * mat.m[0][2] + y * mat.m[1][2] + z * mat.m[2][2] + w * mat.m[3][2];
    result.w = x * mat.m[0][3] + y * mat.m[1][3] + z * mat.m[2][3] + w * mat.m[3][3];
    return result;
}

// также не забываем, что после проекции нужно сделать её перспективной, поделив на компоненту W. По этому добавляем нужный метод

// Деление x, y, z на w (для проекции)
void projectionDiv() {
    x /= w;
    y /= w;
    z /= w;
}
```
```cpp
// Triangle

// Повторяем те же методы и для класса треугольника, так как с помощью него мы изменяем векторы

// Проецирование треугольника (деление на w)
void Triangle::projectionDiv() {
    for (size_t i = 0; i < 3; i++) {
        // Деление координат вершины на w
        p[i].projectionDiv();
    }
}

// Умножение треугольника на матрицу трансформации
Triangle Triangle::operator*(const Mat4x4& mat) {
    Triangle result = *this;
    for (size_t i = 0; i < 3; i++) {
        result.p[i] = p[i] * mat;
    }
    return result;
}

// Также сделаем оператор с присваиванием для удобства использования
// Умножение треугольника на матрицу с присваиванием
Triangle& Triangle::operator*=(const Mat4x4& mat) {
    for (size_t i = 0; i < 3; i++) {
        p[i] = p[i] * mat;
    }
    return *this;
}
```